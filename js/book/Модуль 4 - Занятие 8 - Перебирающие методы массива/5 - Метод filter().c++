===Метод filter()===
---
Метод filter(callback) используется для единственной операции - фильтрации массива, 
то есть когда необходимо выбрать более одного элемента из коллекции по какому-то критерию.
---
массив.filter((element, index, array) => {
  // Тело коллбек-функции
});
---
- Не изменяет оригинальный массив.
- Поэлементно перебирает оригинальный массив.
- Возвращает новый массив.
- Добавляет в возвращаемый массив элементы которые удовлетворяют условию коллбек-функции.
- Если коллбек вернул true элемент добавляется в возвращаемый массив.
- Если коллбек вернул false элемент не добавляется в возвращаемый массив.
- Если ни один элемент не удовлетворил условию, возвращает пустой массив.
---
const values = [51, -3, 27, 21, -68, 42, -37];

const positiveValues = values.filter(value => value >= 0);
console.log(positiveValues); // [51, 27, 21, 42]

const negativeValues = values.filter(value => value < 0);
console.log(negativeValues); // [-3, -68, -37]

const bigValues = values.filter(value => value > 1000);
console.log(bigValues); // []

// Оригинальный массив не изменился
console.log(values); // [51, -3, 27, 21, -68, 42, -37]
---
То есть метод filter вызывает коллбек-функцию для каждого элемента исходного массива 
и если результат её выполнения true, 
текущий элемент добавляет в новый массив.
---
===Фильтрация уникальных элементов===
---
Используя метод filter() можно выполнить фильтрацию массива так, что в нём останутся только уникальные элементы. Этот приём работает только с массивом примитивных значений - не объектов.
Вернёмся к группе студентов и массиву всех посещаемых предметов, которые мы получили методом flatMap().
---
const students = [
  { name: "Манго", courses: ["математика", "физика"] },
  { name: "Поли", courses: ["информатика", "математика"] },
  { name: "Киви", courses: ["физика", "биология"] },
];
const allCourses = students.flatMap(student => student.courses);
// ['математика', 'физика', 'информатика', 'математика', 'физика', 'биология'];
---
В переменной allCourses хранится массив всех посещаемых предметов, которые могут повторяться. 
Задача заключается в том, чтобы сделать новый массив, 
в котором будут только уникальные предметы, то есть без повторений.
---
const uniqueCourses = allCourses.filter(
  (course, index, array) => array.indexOf(course) === index
);
---
Используя array.indexOf(course) выполняем поиск первого совпадения текущего элемента course 
и получаем его индекс в оригинальном массиве всех курсов. 
В параметре index хранится индекс текущего элемента course при переборе массива методом filter.
---
Если результат indexOf() и значение index равны - это уникальный элемент, 
потому что это первый раз когда такое значение встречается в массиве 
и на текущей итерации фильтр обрабатывает именно его.
---
# Массив всех курсов
['математика', 'физика', 'информатика', 'математика', 'физика', 'биология'];
---
Для элемента 'математика' под индексом 0:

indexOf() вернёт 0, потому что ищет первое совпадение.
- Значение параметра index будет 0.
- Они равны, значит это уникальный элемент.
- Для элемента 'математика' под индексом 3:

indexOf() вернёт 0, потому что ищет первое совпадение.
- Значение параметра index будет 3.
- Они не равны, значит это повторяющийся - не уникальный элемент.
---
===Массив объектов===
При работе с массивом объектов выполняется фильтрация по значению какого-то свойства. В результате получается новый массив отфильтрованных объектов.
Например, есть массив студентов с баллами за тест. Необходимо отфильтровать лучших (балл выше 80), худших (балл ниже 50) и средних студентов (балл от 50 до 80).
---
const LOW_SCORE = 50;
const HIGH_SCORE = 80;
const students = [
  { name: "Манго", score: 83 },
  { name: "Поли", score: 59 },
  { name: "Аякс", score: 37 },
  { name: "Киви", score: 94 },
  { name: "Хьюстон", score: 64 },
];
const best = students.filter(student => student.score >= HIGH_SCORE);
console.log(best); // Массив объектов с именами Манго и Киви
const worst = students.filter(student => student.score < LOW_SCORE);
console.log(worst); // Массив с одним объектом Аякс
// В коллбек-функции удобно деструктуризировать свойства объекта
const average = students.filter(
  ({ score }) => score >= LOW_SCORE && score < HIGH_SCORE
);
console.log(average); // Массив объектов с именами Поли и Хьюстон

